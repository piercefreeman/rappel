"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import sys
import typing

import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class SourceLocation(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Source Location Tracking
    -----------------------------------------------------------------------------
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LINENO_FIELD_NUMBER: builtins.int
    COL_OFFSET_FIELD_NUMBER: builtins.int
    END_LINENO_FIELD_NUMBER: builtins.int
    END_COL_OFFSET_FIELD_NUMBER: builtins.int
    lineno: builtins.int
    col_offset: builtins.int
    end_lineno: builtins.int
    end_col_offset: builtins.int
    def __init__(
        self,
        *,
        lineno: builtins.int = ...,
        col_offset: builtins.int = ...,
        end_lineno: builtins.int | None = ...,
        end_col_offset: builtins.int | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_end_col_offset",
            b"_end_col_offset",
            "_end_lineno",
            b"_end_lineno",
            "end_col_offset",
            b"end_col_offset",
            "end_lineno",
            b"end_lineno",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_end_col_offset",
            b"_end_col_offset",
            "_end_lineno",
            b"_end_lineno",
            "col_offset",
            b"col_offset",
            "end_col_offset",
            b"end_col_offset",
            "end_lineno",
            b"end_lineno",
            "lineno",
            b"lineno",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_end_col_offset", b"_end_col_offset"]
    ) -> typing.Literal["end_col_offset"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_end_lineno", b"_end_lineno"]
    ) -> typing.Literal["end_lineno"] | None: ...

Global___SourceLocation: typing_extensions.TypeAlias = SourceLocation

@typing.final
class BackoffConfig(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Execution Policies
    -----------------------------------------------------------------------------

    DSL: [policy: backoff=linear(100ms)] or [policy: backoff=exp(100ms, 2.0x)]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Kind:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _KindEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BackoffConfig._Kind.ValueType],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        KIND_UNSPECIFIED: BackoffConfig._Kind.ValueType  # 0
        KIND_LINEAR: BackoffConfig._Kind.ValueType  # 1
        """DSL: backoff=linear(100ms)"""
        KIND_EXPONENTIAL: BackoffConfig._Kind.ValueType  # 2
        """DSL: backoff=exp(100ms, 2.0x)"""

    class Kind(_Kind, metaclass=_KindEnumTypeWrapper): ...
    KIND_UNSPECIFIED: BackoffConfig.Kind.ValueType  # 0
    KIND_LINEAR: BackoffConfig.Kind.ValueType  # 1
    """DSL: backoff=linear(100ms)"""
    KIND_EXPONENTIAL: BackoffConfig.Kind.ValueType  # 2
    """DSL: backoff=exp(100ms, 2.0x)"""

    KIND_FIELD_NUMBER: builtins.int
    BASE_DELAY_MS_FIELD_NUMBER: builtins.int
    MULTIPLIER_FIELD_NUMBER: builtins.int
    kind: Global___BackoffConfig.Kind.ValueType
    base_delay_ms: builtins.int
    multiplier: builtins.float
    """Only for exponential"""
    def __init__(
        self,
        *,
        kind: Global___BackoffConfig.Kind.ValueType = ...,
        base_delay_ms: builtins.int = ...,
        multiplier: builtins.float | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["_multiplier", b"_multiplier", "multiplier", b"multiplier"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_multiplier",
            b"_multiplier",
            "base_delay_ms",
            b"base_delay_ms",
            "kind",
            b"kind",
            "multiplier",
            b"multiplier",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_multiplier", b"_multiplier"]
    ) -> typing.Literal["multiplier"] | None: ...

Global___BackoffConfig: typing_extensions.TypeAlias = BackoffConfig

@typing.final
class RunActionConfig(google.protobuf.message.Message):
    """DSL: [policy: timeout=60s, retry=3, backoff=exp(100ms, 2.0x)]"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TIMEOUT_SECONDS_FIELD_NUMBER: builtins.int
    MAX_RETRIES_FIELD_NUMBER: builtins.int
    BACKOFF_FIELD_NUMBER: builtins.int
    timeout_seconds: builtins.int
    """DSL: timeout=60s"""
    max_retries: builtins.int
    """DSL: retry=3"""
    @property
    def backoff(self) -> Global___BackoffConfig: ...
    def __init__(
        self,
        *,
        timeout_seconds: builtins.int | None = ...,
        max_retries: builtins.int | None = ...,
        backoff: Global___BackoffConfig | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_backoff",
            b"_backoff",
            "_max_retries",
            b"_max_retries",
            "_timeout_seconds",
            b"_timeout_seconds",
            "backoff",
            b"backoff",
            "max_retries",
            b"max_retries",
            "timeout_seconds",
            b"timeout_seconds",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_backoff",
            b"_backoff",
            "_max_retries",
            b"_max_retries",
            "_timeout_seconds",
            b"_timeout_seconds",
            "backoff",
            b"backoff",
            "max_retries",
            b"max_retries",
            "timeout_seconds",
            b"timeout_seconds",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_backoff", b"_backoff"]
    ) -> typing.Literal["backoff"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_max_retries", b"_max_retries"]
    ) -> typing.Literal["max_retries"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_timeout_seconds", b"_timeout_seconds"]
    ) -> typing.Literal["timeout_seconds"] | None: ...

Global___RunActionConfig: typing_extensions.TypeAlias = RunActionConfig

@typing.final
class Literal(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Expressions - Structured representation for Rust-side evaluation
    -----------------------------------------------------------------------------

    JSON-compatible literal values
    DSL Examples: null, true, false, 42, 3.14, "hello"
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NULL_VALUE_FIELD_NUMBER: builtins.int
    BOOL_VALUE_FIELD_NUMBER: builtins.int
    INT_VALUE_FIELD_NUMBER: builtins.int
    FLOAT_VALUE_FIELD_NUMBER: builtins.int
    STRING_VALUE_FIELD_NUMBER: builtins.int
    null_value: builtins.bool
    """DSL: null"""
    bool_value: builtins.bool
    """DSL: true, false"""
    int_value: builtins.int
    """DSL: 42, -1, 0"""
    float_value: builtins.float
    """DSL: 3.14, -0.5"""
    string_value: builtins.str
    """DSL: "hello" """
    def __init__(
        self,
        *,
        null_value: builtins.bool = ...,
        bool_value: builtins.bool = ...,
        int_value: builtins.int = ...,
        float_value: builtins.float = ...,
        string_value: builtins.str = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "bool_value",
            b"bool_value",
            "float_value",
            b"float_value",
            "int_value",
            b"int_value",
            "null_value",
            b"null_value",
            "string_value",
            b"string_value",
            "value",
            b"value",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "bool_value",
            b"bool_value",
            "float_value",
            b"float_value",
            "int_value",
            b"int_value",
            "null_value",
            b"null_value",
            "string_value",
            b"string_value",
            "value",
            b"value",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["value", b"value"]
    ) -> (
        typing.Literal["null_value", "bool_value", "int_value", "float_value", "string_value"]
        | None
    ): ...

Global___Literal: typing_extensions.TypeAlias = Literal

@typing.final
class Expression(google.protobuf.message.Message):
    """A structured expression that can be evaluated in Rust
    DSL: Any expression like variables, operators, subscripts, etc.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LITERAL_FIELD_NUMBER: builtins.int
    VARIABLE_FIELD_NUMBER: builtins.int
    SUBSCRIPT_FIELD_NUMBER: builtins.int
    ARRAY_FIELD_NUMBER: builtins.int
    DICT_FIELD_NUMBER: builtins.int
    BINARY_OP_FIELD_NUMBER: builtins.int
    UNARY_OP_FIELD_NUMBER: builtins.int
    CALL_FIELD_NUMBER: builtins.int
    ATTRIBUTE_FIELD_NUMBER: builtins.int
    variable: builtins.str
    """DSL: result, item, my_var"""
    @property
    def literal(self) -> Global___Literal:
        """DSL: null, true, 42, 3.14, "hello" """

    @property
    def subscript(self) -> Global___Subscript:
        """DSL: expr["key"], expr[0]"""

    @property
    def array(self) -> Global___ArrayExpr:
        """DSL: [1, 2, 3]"""

    @property
    def dict(self) -> Global___DictExpr:
        """DSL: {"a": 1, "b": 2}"""

    @property
    def binary_op(self) -> Global___BinaryOp:
        """DSL: a + b, a > b, x and y"""

    @property
    def unary_op(self) -> Global___UnaryOp:
        """DSL: not x, -x"""

    @property
    def call(self) -> Global___CallExpr:
        """DSL: len(x), str(x)"""

    @property
    def attribute(self) -> Global___AttributeAccess:
        """DSL: obj.attr"""

    def __init__(
        self,
        *,
        literal: Global___Literal | None = ...,
        variable: builtins.str = ...,
        subscript: Global___Subscript | None = ...,
        array: Global___ArrayExpr | None = ...,
        dict: Global___DictExpr | None = ...,
        binary_op: Global___BinaryOp | None = ...,
        unary_op: Global___UnaryOp | None = ...,
        call: Global___CallExpr | None = ...,
        attribute: Global___AttributeAccess | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "array",
            b"array",
            "attribute",
            b"attribute",
            "binary_op",
            b"binary_op",
            "call",
            b"call",
            "dict",
            b"dict",
            "kind",
            b"kind",
            "literal",
            b"literal",
            "subscript",
            b"subscript",
            "unary_op",
            b"unary_op",
            "variable",
            b"variable",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "array",
            b"array",
            "attribute",
            b"attribute",
            "binary_op",
            b"binary_op",
            "call",
            b"call",
            "dict",
            b"dict",
            "kind",
            b"kind",
            "literal",
            b"literal",
            "subscript",
            b"subscript",
            "unary_op",
            b"unary_op",
            "variable",
            b"variable",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["kind", b"kind"]
    ) -> (
        typing.Literal[
            "literal",
            "variable",
            "subscript",
            "array",
            "dict",
            "binary_op",
            "unary_op",
            "call",
            "attribute",
        ]
        | None
    ): ...

Global___Expression: typing_extensions.TypeAlias = Expression

@typing.final
class Subscript(google.protobuf.message.Message):
    """Subscript access
    DSL: base["key"] or base[0]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BASE_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    @property
    def base(self) -> Global___Expression:
        """The expression being subscripted"""

    @property
    def key(self) -> Global___Expression:
        """The key (string for dict, int for list)"""

    def __init__(
        self,
        *,
        base: Global___Expression | None = ...,
        key: Global___Expression | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["base", b"base", "key", b"key"]
    ) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["base", b"base", "key", b"key"]) -> None: ...

Global___Subscript: typing_extensions.TypeAlias = Subscript

@typing.final
class AttributeAccess(google.protobuf.message.Message):
    """Attribute access
    DSL: base.attr
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BASE_FIELD_NUMBER: builtins.int
    ATTRIBUTE_FIELD_NUMBER: builtins.int
    attribute: builtins.str
    """The attribute name"""
    @property
    def base(self) -> Global___Expression:
        """The expression being accessed"""

    def __init__(
        self,
        *,
        base: Global___Expression | None = ...,
        attribute: builtins.str = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["base", b"base"]) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["attribute", b"attribute", "base", b"base"]
    ) -> None: ...

Global___AttributeAccess: typing_extensions.TypeAlias = AttributeAccess

@typing.final
class ArrayExpr(google.protobuf.message.Message):
    """Array literal expression
    DSL: [elem1, elem2, elem3]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ELEMENTS_FIELD_NUMBER: builtins.int
    @property
    def elements(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___Expression
    ]: ...
    def __init__(
        self,
        *,
        elements: collections.abc.Iterable[Global___Expression] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["elements", b"elements"]) -> None: ...

Global___ArrayExpr: typing_extensions.TypeAlias = ArrayExpr

@typing.final
class DictExpr(google.protobuf.message.Message):
    """Dict literal expression
    DSL: {"key1": value1, "key2": value2}
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___DictEntry
    ]: ...
    def __init__(
        self,
        *,
        entries: collections.abc.Iterable[Global___DictEntry] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["entries", b"entries"]) -> None: ...

Global___DictExpr: typing_extensions.TypeAlias = DictExpr

@typing.final
class DictEntry(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    key: builtins.str
    """Dict keys are always strings in JSON"""
    @property
    def value(self) -> Global___Expression: ...
    def __init__(
        self,
        *,
        key: builtins.str = ...,
        value: Global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

Global___DictEntry: typing_extensions.TypeAlias = DictEntry

@typing.final
class BinaryOp(google.protobuf.message.Message):
    """Binary operation
    DSL: left OP right
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Op:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OpEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BinaryOp._Op.ValueType],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        OP_UNSPECIFIED: BinaryOp._Op.ValueType  # 0
        OP_ADD: BinaryOp._Op.ValueType  # 1
        """Arithmetic: DSL uses +, -, *, /, %
        DSL: a + b
        """
        OP_SUB: BinaryOp._Op.ValueType  # 2
        """DSL: a - b"""
        OP_MUL: BinaryOp._Op.ValueType  # 3
        """DSL: a * b"""
        OP_DIV: BinaryOp._Op.ValueType  # 4
        """DSL: a / b"""
        OP_MOD: BinaryOp._Op.ValueType  # 5
        """DSL: a % b"""
        OP_EQ: BinaryOp._Op.ValueType  # 10
        """Comparison: DSL uses ==, !=, <, <=, >, >=
        DSL: a == b
        """
        OP_NE: BinaryOp._Op.ValueType  # 11
        """DSL: a != b"""
        OP_LT: BinaryOp._Op.ValueType  # 12
        """DSL: a < b"""
        OP_LE: BinaryOp._Op.ValueType  # 13
        """DSL: a <= b"""
        OP_GT: BinaryOp._Op.ValueType  # 14
        """DSL: a > b"""
        OP_GE: BinaryOp._Op.ValueType  # 15
        """DSL: a >= b"""
        OP_AND: BinaryOp._Op.ValueType  # 20
        """Logical: DSL uses 'and', 'or'
        DSL: a and b
        """
        OP_OR: BinaryOp._Op.ValueType  # 21
        """DSL: a or b"""
        OP_IN: BinaryOp._Op.ValueType  # 30
        """Membership: DSL uses 'in', 'not in'
        DSL: a in b
        """
        OP_NOT_IN: BinaryOp._Op.ValueType  # 31
        """DSL: a not in b"""

    class Op(_Op, metaclass=_OpEnumTypeWrapper): ...
    OP_UNSPECIFIED: BinaryOp.Op.ValueType  # 0
    OP_ADD: BinaryOp.Op.ValueType  # 1
    """Arithmetic: DSL uses +, -, *, /, %
    DSL: a + b
    """
    OP_SUB: BinaryOp.Op.ValueType  # 2
    """DSL: a - b"""
    OP_MUL: BinaryOp.Op.ValueType  # 3
    """DSL: a * b"""
    OP_DIV: BinaryOp.Op.ValueType  # 4
    """DSL: a / b"""
    OP_MOD: BinaryOp.Op.ValueType  # 5
    """DSL: a % b"""
    OP_EQ: BinaryOp.Op.ValueType  # 10
    """Comparison: DSL uses ==, !=, <, <=, >, >=
    DSL: a == b
    """
    OP_NE: BinaryOp.Op.ValueType  # 11
    """DSL: a != b"""
    OP_LT: BinaryOp.Op.ValueType  # 12
    """DSL: a < b"""
    OP_LE: BinaryOp.Op.ValueType  # 13
    """DSL: a <= b"""
    OP_GT: BinaryOp.Op.ValueType  # 14
    """DSL: a > b"""
    OP_GE: BinaryOp.Op.ValueType  # 15
    """DSL: a >= b"""
    OP_AND: BinaryOp.Op.ValueType  # 20
    """Logical: DSL uses 'and', 'or'
    DSL: a and b
    """
    OP_OR: BinaryOp.Op.ValueType  # 21
    """DSL: a or b"""
    OP_IN: BinaryOp.Op.ValueType  # 30
    """Membership: DSL uses 'in', 'not in'
    DSL: a in b
    """
    OP_NOT_IN: BinaryOp.Op.ValueType  # 31
    """DSL: a not in b"""

    OP_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    op: Global___BinaryOp.Op.ValueType
    @property
    def left(self) -> Global___Expression: ...
    @property
    def right(self) -> Global___Expression: ...
    def __init__(
        self,
        *,
        op: Global___BinaryOp.Op.ValueType = ...,
        left: Global___Expression | None = ...,
        right: Global___Expression | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["left", b"left", "right", b"right"]
    ) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["left", b"left", "op", b"op", "right", b"right"]
    ) -> None: ...

Global___BinaryOp: typing_extensions.TypeAlias = BinaryOp

@typing.final
class UnaryOp(google.protobuf.message.Message):
    """Unary operation
    DSL: OP operand
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Op:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OpEnumTypeWrapper(
        google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[UnaryOp._Op.ValueType],
        builtins.type,
    ):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        OP_UNSPECIFIED: UnaryOp._Op.ValueType  # 0
        OP_NOT: UnaryOp._Op.ValueType  # 1
        """DSL: not x"""
        OP_NEG: UnaryOp._Op.ValueType  # 2
        """DSL: -x"""

    class Op(_Op, metaclass=_OpEnumTypeWrapper): ...
    OP_UNSPECIFIED: UnaryOp.Op.ValueType  # 0
    OP_NOT: UnaryOp.Op.ValueType  # 1
    """DSL: not x"""
    OP_NEG: UnaryOp.Op.ValueType  # 2
    """DSL: -x"""

    OP_FIELD_NUMBER: builtins.int
    OPERAND_FIELD_NUMBER: builtins.int
    op: Global___UnaryOp.Op.ValueType
    @property
    def operand(self) -> Global___Expression: ...
    def __init__(
        self,
        *,
        op: Global___UnaryOp.Op.ValueType = ...,
        operand: Global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["operand", b"operand"]) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["op", b"op", "operand", b"operand"]
    ) -> None: ...

Global___UnaryOp: typing_extensions.TypeAlias = UnaryOp

@typing.final
class CallExpr(google.protobuf.message.Message):
    """Safe function call (allowlisted functions only)
    DSL: function(arg1, arg2)
    Allowed: len, str, int, float, bool, list, dict, tuple, set, sum, min, max, abs, etc.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FUNCTION_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    function: builtins.str
    """Function name"""
    @property
    def args(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___Expression
    ]: ...
    def __init__(
        self,
        *,
        function: builtins.str = ...,
        args: collections.abc.Iterable[Global___Expression] | None = ...,
    ) -> None: ...
    def ClearField(
        self, field_name: typing.Literal["args", b"args", "function", b"function"]
    ) -> None: ...

Global___CallExpr: typing_extensions.TypeAlias = CallExpr

@typing.final
class KwArg(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Core IR Nodes
    -----------------------------------------------------------------------------

    Structured keyword argument
    DSL: name=value (within function calls)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    name: builtins.str
    @property
    def value(self) -> Global___Expression: ...
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        value: Global___Expression | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
    def ClearField(
        self, field_name: typing.Literal["name", b"name", "value", b"value"]
    ) -> None: ...

Global___KwArg: typing_extensions.TypeAlias = KwArg

@typing.final
class ActionCall(google.protobuf.message.Message):
    """A single action invocation - the fundamental unit of durable execution
    DSL: target = @module.action(arg1=val1, arg2=val2) [policy: timeout=60s]
    DSL: @module.action(arg=val)  // no target assignment
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACTION_FIELD_NUMBER: builtins.int
    MODULE_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    action: builtins.str
    """Action name"""
    module: builtins.str
    """Module where action is defined"""
    target: builtins.str
    """Variable to assign result to"""
    @property
    def args(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___KwArg]:
        """Structured arguments"""

    @property
    def config(self) -> Global___RunActionConfig: ...
    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        action: builtins.str = ...,
        module: builtins.str | None = ...,
        args: collections.abc.Iterable[Global___KwArg] | None = ...,
        target: builtins.str | None = ...,
        config: Global___RunActionConfig | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_config",
            b"_config",
            "_location",
            b"_location",
            "_module",
            b"_module",
            "_target",
            b"_target",
            "config",
            b"config",
            "location",
            b"location",
            "module",
            b"module",
            "target",
            b"target",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_config",
            b"_config",
            "_location",
            b"_location",
            "_module",
            b"_module",
            "_target",
            b"_target",
            "action",
            b"action",
            "args",
            b"args",
            "config",
            b"config",
            "location",
            b"location",
            "module",
            b"module",
            "target",
            b"target",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_config", b"_config"]
    ) -> typing.Literal["config"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_module", b"_module"]
    ) -> typing.Literal["module"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_target", b"_target"]
    ) -> typing.Literal["target"] | None: ...

Global___ActionCall: typing_extensions.TypeAlias = ActionCall

@typing.final
class SubgraphCall(google.protobuf.message.Message):
    """Invocation of a sub-graph (another method on the workflow class)
    DSL: target = self.method_name(arg1=val1, arg2=val2)
    DSL: self.method_name()  // no target assignment
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METHOD_NAME_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    method_name: builtins.str
    """Name of the method to invoke"""
    target: builtins.str
    """Variable to assign result to"""
    @property
    def args(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___KwArg]:
        """Structured arguments"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        method_name: builtins.str = ...,
        args: collections.abc.Iterable[Global___KwArg] | None = ...,
        target: builtins.str | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "location",
            b"location",
            "target",
            b"target",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "args",
            b"args",
            "location",
            b"location",
            "method_name",
            b"method_name",
            "target",
            b"target",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_target", b"_target"]
    ) -> typing.Literal["target"] | None: ...

Global___SubgraphCall: typing_extensions.TypeAlias = SubgraphCall

@typing.final
class GatherCall(google.protobuf.message.Message):
    """A callable unit in gather - either an action or a subgraph"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACTION_FIELD_NUMBER: builtins.int
    SUBGRAPH_FIELD_NUMBER: builtins.int
    @property
    def action(self) -> Global___ActionCall: ...
    @property
    def subgraph(self) -> Global___SubgraphCall: ...
    def __init__(
        self,
        *,
        action: Global___ActionCall | None = ...,
        subgraph: Global___SubgraphCall | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal["action", b"action", "kind", b"kind", "subgraph", b"subgraph"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal["action", b"action", "kind", b"kind", "subgraph", b"subgraph"],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["kind", b"kind"]
    ) -> typing.Literal["action", "subgraph"] | None: ...

Global___GatherCall: typing_extensions.TypeAlias = GatherCall

@typing.final
class Gather(google.protobuf.message.Message):
    """Parallel execution of multiple actions or subgraphs
    DSL:
      results = parallel(
          @module.action1()
          @module.action2()
          self.subgraph_method(arg=val)
      )
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CALLS_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    target: builtins.str
    """Variable to assign tuple result to"""
    @property
    def calls(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___GatherCall
    ]: ...
    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        calls: collections.abc.Iterable[Global___GatherCall] | None = ...,
        target: builtins.str | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "location",
            b"location",
            "target",
            b"target",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "calls",
            b"calls",
            "location",
            b"location",
            "target",
            b"target",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_target", b"_target"]
    ) -> typing.Literal["target"] | None: ...

Global___Gather: typing_extensions.TypeAlias = Gather

@typing.final
class PythonBlock(google.protobuf.message.Message):
    """Arbitrary Python code that doesn't contain actions (escape hatch)
    DSL:
      python(reads: var1, var2; writes: var3, var4) {
          x = var1 + var2
          var3 = x * 2
      }
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CODE_FIELD_NUMBER: builtins.int
    IMPORTS_FIELD_NUMBER: builtins.int
    DEFINITIONS_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    OUTPUTS_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    code: builtins.str
    @property
    def imports(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Import statements needed"""

    @property
    def definitions(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Function/class definitions needed"""

    @property
    def inputs(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Variables read (DSL: reads: ...)"""

    @property
    def outputs(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Variables written (DSL: writes: ...)"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        code: builtins.str = ...,
        imports: collections.abc.Iterable[builtins.str] | None = ...,
        definitions: collections.abc.Iterable[builtins.str] | None = ...,
        inputs: collections.abc.Iterable[builtins.str] | None = ...,
        outputs: collections.abc.Iterable[builtins.str] | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["_location", b"_location", "location", b"location"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "code",
            b"code",
            "definitions",
            b"definitions",
            "imports",
            b"imports",
            "inputs",
            b"inputs",
            "location",
            b"location",
            "outputs",
            b"outputs",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___PythonBlock: typing_extensions.TypeAlias = PythonBlock

@typing.final
class Loop(google.protobuf.message.Message):
    """A for loop with a sub-graph body
    DSL:
      loop item in collection -> [accumulator]:
          <statements>

    The body receives the loop variable bound to the current item each iteration.
    The accumulator variable collects results (initialized as []).
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ITERATOR_FIELD_NUMBER: builtins.int
    LOOP_VAR_FIELD_NUMBER: builtins.int
    ACCUMULATOR_FIELD_NUMBER: builtins.int
    BODY_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    loop_var: builtins.str
    """DSL: the 'item' variable name"""
    accumulator: builtins.str
    """DSL: the '[accumulator]' variable"""
    @property
    def iterator(self) -> Global___Expression:
        """DSL: the 'collection' expression"""

    @property
    def body(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Statement]:
        """Sub-graph of statements executed each iteration"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        iterator: Global___Expression | None = ...,
        loop_var: builtins.str = ...,
        accumulator: builtins.str = ...,
        body: collections.abc.Iterable[Global___Statement] | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location", b"_location", "iterator", b"iterator", "location", b"location"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "accumulator",
            b"accumulator",
            "body",
            b"body",
            "iterator",
            b"iterator",
            "location",
            b"location",
            "loop_var",
            b"loop_var",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___Loop: typing_extensions.TypeAlias = Loop

@typing.final
class Branch(google.protobuf.message.Message):
    """One branch of a conditional
    DSL:
      branch if guard_expression:   // First branch
      branch elif guard_expression: // Middle branches
      branch else:                  // Last branch (no guard)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GUARD_FIELD_NUMBER: builtins.int
    PREAMBLE_FIELD_NUMBER: builtins.int
    ACTIONS_FIELD_NUMBER: builtins.int
    POSTAMBLE_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    @property
    def guard(self) -> Global___Expression:
        """DSL: the condition expression (empty for else branch)"""

    @property
    def preamble(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___PythonBlock]:
        """DSL: # preamble (code before first action)"""

    @property
    def actions(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ActionCall]:
        """One or more actions (chained in DAG)"""

    @property
    def postamble(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___PythonBlock]:
        """DSL: # postamble (code after last action)"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        guard: Global___Expression | None = ...,
        preamble: collections.abc.Iterable[Global___PythonBlock] | None = ...,
        actions: collections.abc.Iterable[Global___ActionCall] | None = ...,
        postamble: collections.abc.Iterable[Global___PythonBlock] | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location", b"_location", "guard", b"guard", "location", b"location"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "actions",
            b"actions",
            "guard",
            b"guard",
            "location",
            b"location",
            "postamble",
            b"postamble",
            "preamble",
            b"preamble",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___Branch: typing_extensions.TypeAlias = Branch

@typing.final
class Conditional(google.protobuf.message.Message):
    """If/elif/else with actions in each branch
    DSL:
      branch if x > 50:
          result = @module.high_action()
      branch elif x > 25:
          result = @module.medium_action()
      branch else:
          result = @module.low_action()
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    BRANCHES_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    target: builtins.str
    """Common target variable if branches assign"""
    @property
    def branches(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___Branch]:
        """Must cover all cases (else required)"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        branches: collections.abc.Iterable[Global___Branch] | None = ...,
        target: builtins.str | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "location",
            b"location",
            "target",
            b"target",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "branches",
            b"branches",
            "location",
            b"location",
            "target",
            b"target",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_target", b"_target"]
    ) -> typing.Literal["target"] | None: ...

Global___Conditional: typing_extensions.TypeAlias = Conditional

@typing.final
class ExceptHandler(google.protobuf.message.Message):
    """An except handler
    DSL:
      except ValueError:
          <statements>
      except (ValueError, TypeError):
          <statements>
      except module.CustomError:
          <statements>
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXCEPTION_TYPES_FIELD_NUMBER: builtins.int
    PREAMBLE_FIELD_NUMBER: builtins.int
    BODY_FIELD_NUMBER: builtins.int
    POSTAMBLE_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    @property
    def exception_types(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___ExceptionType
    ]: ...
    @property
    def preamble(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___PythonBlock]:
        """Statements before first action"""

    @property
    def body(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ActionCall]:
        """One or more actions"""

    @property
    def postamble(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___PythonBlock]:
        """Statements after last action"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        exception_types: collections.abc.Iterable[Global___ExceptionType] | None = ...,
        preamble: collections.abc.Iterable[Global___PythonBlock] | None = ...,
        body: collections.abc.Iterable[Global___ActionCall] | None = ...,
        postamble: collections.abc.Iterable[Global___PythonBlock] | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["_location", b"_location", "location", b"location"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "body",
            b"body",
            "exception_types",
            b"exception_types",
            "location",
            b"location",
            "postamble",
            b"postamble",
            "preamble",
            b"preamble",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___ExceptHandler: typing_extensions.TypeAlias = ExceptHandler

@typing.final
class ExceptionType(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MODULE_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    module: builtins.str
    """e.g., "mymodule" for mymodule.MyError"""
    name: builtins.str
    """e.g., "ValueError" (None for bare except)"""
    def __init__(
        self,
        *,
        module: builtins.str | None = ...,
        name: builtins.str | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_module", b"_module", "_name", b"_name", "module", b"module", "name", b"name"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_module", b"_module", "_name", b"_name", "module", b"module", "name", b"name"
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_module", b"_module"]
    ) -> typing.Literal["module"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_name", b"_name"]
    ) -> typing.Literal["name"] | None: ...

Global___ExceptionType: typing_extensions.TypeAlias = ExceptionType

@typing.final
class TryExcept(google.protobuf.message.Message):
    """Try/except block with actions
    DSL:
      try:
          result = @module.risky_action()
      except ValueError:
          result = @module.fallback_action()
      except (TypeError, KeyError):
          result = @module.other_fallback()
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TRY_PREAMBLE_FIELD_NUMBER: builtins.int
    TRY_BODY_FIELD_NUMBER: builtins.int
    TRY_POSTAMBLE_FIELD_NUMBER: builtins.int
    HANDLERS_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    @property
    def try_preamble(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___PythonBlock]:
        """Statements before first action in try"""

    @property
    def try_body(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___ActionCall]:
        """One or more actions in try"""

    @property
    def try_postamble(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___PythonBlock]:
        """Statements after last action in try"""

    @property
    def handlers(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___ExceptHandler
    ]: ...
    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        try_preamble: collections.abc.Iterable[Global___PythonBlock] | None = ...,
        try_body: collections.abc.Iterable[Global___ActionCall] | None = ...,
        try_postamble: collections.abc.Iterable[Global___PythonBlock] | None = ...,
        handlers: collections.abc.Iterable[Global___ExceptHandler] | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["_location", b"_location", "location", b"location"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "handlers",
            b"handlers",
            "location",
            b"location",
            "try_body",
            b"try_body",
            "try_postamble",
            b"try_postamble",
            "try_preamble",
            b"try_preamble",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___TryExcept: typing_extensions.TypeAlias = TryExcept

@typing.final
class Sleep(google.protobuf.message.Message):
    """Durable sleep
    DSL: @sleep(60)
    DSL: @sleep(duration_var)
    DSL: @sleep(wait_time * 2)
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DURATION_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    @property
    def duration(self) -> Global___Expression:
        """Duration in seconds (can be expression)"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        duration: Global___Expression | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location", b"_location", "duration", b"duration", "location", b"location"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location", b"_location", "duration", b"duration", "location", b"location"
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___Sleep: typing_extensions.TypeAlias = Sleep

@typing.final
class Return(google.protobuf.message.Message):
    """Return statement
    DSL:
      return                           // No value
      return expression                // Return expression
      return @module.action()          // Return action result
      return parallel(...)             // Return gather result
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    EXPRESSION_FIELD_NUMBER: builtins.int
    ACTION_FIELD_NUMBER: builtins.int
    GATHER_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    @property
    def expression(self) -> Global___Expression:
        """DSL: return expr"""

    @property
    def action(self) -> Global___ActionCall:
        """DSL: return @module.action()"""

    @property
    def gather(self) -> Global___Gather:
        """DSL: return parallel(...)"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        expression: Global___Expression | None = ...,
        action: Global___ActionCall | None = ...,
        gather: Global___Gather | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "action",
            b"action",
            "expression",
            b"expression",
            "gather",
            b"gather",
            "location",
            b"location",
            "value",
            b"value",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "action",
            b"action",
            "expression",
            b"expression",
            "gather",
            b"gather",
            "location",
            b"location",
            "value",
            b"value",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["value", b"value"]
    ) -> typing.Literal["expression", "action", "gather"] | None: ...

Global___Return: typing_extensions.TypeAlias = Return

@typing.final
class Spread(google.protobuf.message.Message):
    """Compile-time expansion of action over collection
    DSL: target = spread @module.action(arg=loop_var) over collection as loop_var

    This is a compile-time construct that expands to parallel action calls.
    Unlike Loop, all iterations execute in parallel.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACTION_FIELD_NUMBER: builtins.int
    LOOP_VAR_FIELD_NUMBER: builtins.int
    ITERABLE_FIELD_NUMBER: builtins.int
    TARGET_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    loop_var: builtins.str
    """DSL: 'as loop_var'"""
    target: builtins.str
    """DSL: 'target = ...'"""
    @property
    def action(self) -> Global___ActionCall:
        """Template action (args reference loop_var)"""

    @property
    def iterable(self) -> Global___Expression:
        """DSL: 'over collection'"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        action: Global___ActionCall | None = ...,
        loop_var: builtins.str = ...,
        iterable: Global___Expression | None = ...,
        target: builtins.str | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "action",
            b"action",
            "iterable",
            b"iterable",
            "location",
            b"location",
            "target",
            b"target",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "_target",
            b"_target",
            "action",
            b"action",
            "iterable",
            b"iterable",
            "location",
            b"location",
            "loop_var",
            b"loop_var",
            "target",
            b"target",
        ],
    ) -> None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...
    @typing.overload
    def WhichOneof(
        self, oneof_group: typing.Literal["_target", b"_target"]
    ) -> typing.Literal["target"] | None: ...

Global___Spread: typing_extensions.TypeAlias = Spread

@typing.final
class ListAppend(google.protobuf.message.Message):
    """Append a value to a list (scheduler-evaluated, no worker dispatch)
    DSL: list_var += [value_expr]
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TARGET_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    target: builtins.str
    """The list variable to append to"""
    @property
    def value(self) -> Global___Expression:
        """The value to append"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        target: builtins.str = ...,
        value: Global___Expression | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location", b"_location", "location", b"location", "value", b"value"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "location",
            b"location",
            "target",
            b"target",
            "value",
            b"value",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___ListAppend: typing_extensions.TypeAlias = ListAppend

@typing.final
class DictSet(google.protobuf.message.Message):
    """Set a key in a dictionary (scheduler-evaluated, no worker dispatch)
    DSL: dict_var[key_expr] = value_expr
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TARGET_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    target: builtins.str
    """The dict variable to modify"""
    @property
    def key(self) -> Global___Expression:
        """The key (can be variable or literal)"""

    @property
    def value(self) -> Global___Expression:
        """The value to set"""

    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        target: builtins.str = ...,
        key: Global___Expression | None = ...,
        value: Global___Expression | None = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_location", b"_location", "key", b"key", "location", b"location", "value", b"value"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location",
            b"_location",
            "key",
            b"key",
            "location",
            b"location",
            "target",
            b"target",
            "value",
            b"value",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___DictSet: typing_extensions.TypeAlias = DictSet

@typing.final
class Statement(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Statement Union
    -----------------------------------------------------------------------------
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ACTION_CALL_FIELD_NUMBER: builtins.int
    GATHER_FIELD_NUMBER: builtins.int
    PYTHON_BLOCK_FIELD_NUMBER: builtins.int
    LOOP_FIELD_NUMBER: builtins.int
    CONDITIONAL_FIELD_NUMBER: builtins.int
    TRY_EXCEPT_FIELD_NUMBER: builtins.int
    SLEEP_FIELD_NUMBER: builtins.int
    RETURN_STMT_FIELD_NUMBER: builtins.int
    SPREAD_FIELD_NUMBER: builtins.int
    LIST_APPEND_FIELD_NUMBER: builtins.int
    DICT_SET_FIELD_NUMBER: builtins.int
    @property
    def action_call(self) -> Global___ActionCall:
        """DSL: @module.action()"""

    @property
    def gather(self) -> Global___Gather:
        """DSL: parallel(...)"""

    @property
    def python_block(self) -> Global___PythonBlock:
        """DSL: python { ... }"""

    @property
    def loop(self) -> Global___Loop:
        """DSL: loop var in expr -> [acc]: ..."""

    @property
    def conditional(self) -> Global___Conditional:
        """DSL: branch if/elif/else"""

    @property
    def try_except(self) -> Global___TryExcept:
        """DSL: try: ... except: ..."""

    @property
    def sleep(self) -> Global___Sleep:
        """DSL: @sleep(duration)"""

    @property
    def return_stmt(self) -> Global___Return:
        """DSL: return ..."""

    @property
    def spread(self) -> Global___Spread:
        """DSL: spread @action() over collection as var"""

    @property
    def list_append(self) -> Global___ListAppend:
        """DSL: list_var += [value]"""

    @property
    def dict_set(self) -> Global___DictSet:
        """DSL: dict_var[key] = value"""

    def __init__(
        self,
        *,
        action_call: Global___ActionCall | None = ...,
        gather: Global___Gather | None = ...,
        python_block: Global___PythonBlock | None = ...,
        loop: Global___Loop | None = ...,
        conditional: Global___Conditional | None = ...,
        try_except: Global___TryExcept | None = ...,
        sleep: Global___Sleep | None = ...,
        return_stmt: Global___Return | None = ...,
        spread: Global___Spread | None = ...,
        list_append: Global___ListAppend | None = ...,
        dict_set: Global___DictSet | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "action_call",
            b"action_call",
            "conditional",
            b"conditional",
            "dict_set",
            b"dict_set",
            "gather",
            b"gather",
            "kind",
            b"kind",
            "list_append",
            b"list_append",
            "loop",
            b"loop",
            "python_block",
            b"python_block",
            "return_stmt",
            b"return_stmt",
            "sleep",
            b"sleep",
            "spread",
            b"spread",
            "try_except",
            b"try_except",
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "action_call",
            b"action_call",
            "conditional",
            b"conditional",
            "dict_set",
            b"dict_set",
            "gather",
            b"gather",
            "kind",
            b"kind",
            "list_append",
            b"list_append",
            "loop",
            b"loop",
            "python_block",
            b"python_block",
            "return_stmt",
            b"return_stmt",
            "sleep",
            b"sleep",
            "spread",
            b"spread",
            "try_except",
            b"try_except",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["kind", b"kind"]
    ) -> (
        typing.Literal[
            "action_call",
            "gather",
            "python_block",
            "loop",
            "conditional",
            "try_except",
            "sleep",
            "return_stmt",
            "spread",
            "list_append",
            "dict_set",
        ]
        | None
    ): ...

Global___Statement: typing_extensions.TypeAlias = Statement

@typing.final
class WorkflowParam(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Workflow Definition
    -----------------------------------------------------------------------------

    DSL: workflow WorkflowName(param1: Type1, param2: Type2) -> ReturnType:
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    TYPE_ANNOTATION_FIELD_NUMBER: builtins.int
    name: builtins.str
    type_annotation: builtins.str
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        type_annotation: builtins.str | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal[
            "_type_annotation", b"_type_annotation", "type_annotation", b"type_annotation"
        ],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_type_annotation",
            b"_type_annotation",
            "name",
            b"name",
            "type_annotation",
            b"type_annotation",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_type_annotation", b"_type_annotation"]
    ) -> typing.Literal["type_annotation"] | None: ...

Global___WorkflowParam: typing_extensions.TypeAlias = WorkflowParam

@typing.final
class Workflow(google.protobuf.message.Message):
    """DSL:
    workflow MyWorkflow(items: list[int], threshold: float = 0.5) -> dict:
        <statements>
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    PARAMS_FIELD_NUMBER: builtins.int
    BODY_FIELD_NUMBER: builtins.int
    RETURN_TYPE_FIELD_NUMBER: builtins.int
    name: builtins.str
    return_type: builtins.str
    @property
    def params(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___WorkflowParam
    ]: ...
    @property
    def body(
        self,
    ) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[
        Global___Statement
    ]: ...
    def __init__(
        self,
        *,
        name: builtins.str = ...,
        params: collections.abc.Iterable[Global___WorkflowParam] | None = ...,
        body: collections.abc.Iterable[Global___Statement] | None = ...,
        return_type: builtins.str | None = ...,
    ) -> None: ...
    def HasField(
        self,
        field_name: typing.Literal["_return_type", b"_return_type", "return_type", b"return_type"],
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_return_type",
            b"_return_type",
            "body",
            b"body",
            "name",
            b"name",
            "params",
            b"params",
            "return_type",
            b"return_type",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_return_type", b"_return_type"]
    ) -> typing.Literal["return_type"] | None: ...

Global___Workflow: typing_extensions.TypeAlias = Workflow

@typing.final
class ActionDefinition(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Action Definition (for module resolution and signature mapping)
    -----------------------------------------------------------------------------
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    MODULE_FIELD_NUMBER: builtins.int
    PARAM_NAMES_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Action name as registered"""
    module: builtins.str
    """Module where action is defined"""
    @property
    def param_names(
        self,
    ) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Ordered parameter names for positional mapping"""

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        module: builtins.str | None = ...,
        param_names: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["_module", b"_module", "module", b"module"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_module",
            b"_module",
            "module",
            b"module",
            "name",
            b"name",
            "param_names",
            b"param_names",
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_module", b"_module"]
    ) -> typing.Literal["module"] | None: ...

Global___ActionDefinition: typing_extensions.TypeAlias = ActionDefinition

@typing.final
class ParseError(google.protobuf.message.Message):
    """-----------------------------------------------------------------------------
    Parse Error
    -----------------------------------------------------------------------------
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MESSAGE_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    message: builtins.str
    @property
    def location(self) -> Global___SourceLocation: ...
    def __init__(
        self,
        *,
        message: builtins.str = ...,
        location: Global___SourceLocation | None = ...,
    ) -> None: ...
    def HasField(
        self, field_name: typing.Literal["_location", b"_location", "location", b"location"]
    ) -> builtins.bool: ...
    def ClearField(
        self,
        field_name: typing.Literal[
            "_location", b"_location", "location", b"location", "message", b"message"
        ],
    ) -> None: ...
    def WhichOneof(
        self, oneof_group: typing.Literal["_location", b"_location"]
    ) -> typing.Literal["location"] | None: ...

Global___ParseError: typing_extensions.TypeAlias = ParseError
